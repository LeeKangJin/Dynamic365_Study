// <copyright file="PreOperationnew_weekly_report_detailUpdate.cs" company="">
// Copyright (c) 2020 All Rights Reserved
// </copyright>
// <author></author>
// <date>2020-01-08 오후 5:39:41</date>
// <summary>Implements the PreOperationnew_weekly_report_detailUpdate Plugin.</summary>
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
// </auto-generated>

using System;
using System.ServiceModel;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Query;

namespace CellCrmVSSolution1.CellCRMPlugin
{


   
    /// <summary>
    /// PreOperationnew_weekly_report_detailUpdate Plugin.
    /// </summary>    
    public class PreOperationnew_weekly_report_detailUpdate : PluginBase
    {
        private static readonly object SyncLock = new object();
        /// <summary>
        /// Initializes a new instance of the <see cref="PreOperationnew_weekly_report_detailUpdate"/> class.
        /// </summary>
        /// <param name="unsecure">Contains public (unsecured) configuration information.</param>
        /// <param name="secure">Contains non-public (secured) configuration information. 
        /// When using Microsoft Dynamics 365 for Outlook with Offline Access, 
        /// the secure string is not passed to a plug-in that executes while the client is offline.</param>
        public PreOperationnew_weekly_report_detailUpdate(string unsecure, string secure)
            : base(typeof(PreOperationnew_weekly_report_detailUpdate))
        {

            // TODO: Implement your custom configuration handling.
        }


        /// <summary>
        /// Main entry point for he business logic that the plug-in is to execute.
        /// </summary>
        /// <param name="localContext">The <see cref="LocalPluginContext"/> which contains the
        /// <see cref="IPluginExecutionContext"/>,
        /// <see cref="IOrganizationService"/>
        /// and <see cref="ITracingService"/>
        /// </param>
        /// <remarks>
        /// For improved performance, Microsoft Dynamics 365 caches plug-in instances.
        /// The plug-in's Execute method should be written to be stateless as the constructor
        /// is not called for every invocation of the plug-in. Also, multiple system threads
        /// could execute the plug-in at the same time. All per invocation state information
        /// is stored in the context. This means that you should not use global variables in plug-ins.
        /// </remarks>
        protected override void ExecuteCrmPlugin(LocalPluginContext localContext)
        {
            if (localContext == null)
            {
                throw new InvalidPluginExecutionException("localContext");
            }

            try
            {
                IPluginExecutionContext context = localContext.PluginExecutionContext;
                IOrganizationService service = localContext.OrganizationService;

                if (context.IsInTransaction)
                {
                    lock (SyncLock)
                    {
                        if (context.InputParameters["Target"] is Entity)
                        {

                            Entity target = (Entity)context.InputParameters["Target"];

                            //retreive (target.id)
                            Entity reportDetail = service.Retrieve("new_weekly_report_detail", target.Id, new Microsoft.Xrm.Sdk.Query.ColumnSet(true
                                //"new_l_task",
                                //"new_i_week",
                                ));


                            if (reportDetail.Contains("new_l_task"))
                            {

                                // Function 화
                                EntityReference task = new EntityReference("task", (((EntityReference)reportDetail["new_l_task"]).Id));
                                ConditionExpression ce = new ConditionExpression(); //  task 이름이랑 같은 값이 주간업무보고에 포함되어 있는지
                                ce.AttributeName = "new_l_task";
                                ce.Operator = ConditionOperator.Equal;
                                ce.Values.Add(task);

                                FilterExpression fe = new FilterExpression();
                                fe.Conditions.Add(ce);

                                QueryExpression qe = new QueryExpression("new_weekly_report_detail");
                                qe.ColumnSet.AddColumns("new_l_task");
                                qe.Criteria.AddFilter(fe);

                                EntityCollection ec = service.RetrieveMultiple(qe);

                                if (ec.Entities.Count == 1)
                                {
                                    // just update
                                    //    task["scheduledend"]
                                    //    task["scheduledstart"]
                                    //    task["actualdurationminutes"]
                                    //    task["regardingobjectid"]

                                }
                                else
                                {

                                    int min = Convert.ToInt32(reportDetail["new_i_week"]);
                                    int max = Convert.ToInt32(reportDetail["new_i_week"]);
                                    int my = Convert.ToInt32(reportDetail["new_i_week"]);
                                    foreach (var anotherDetail in ec.Entities)
                                    {

                                        Entity anoterRpoertDetail = service.Retrieve("new_weekly_report_detail", anotherDetail.Id, new Microsoft.Xrm.Sdk.Query.ColumnSet(true
                                            // 필요한 INDEX 만 뽑기                                            
                                            ));
                                        // 1안 index 숫자 가져와서
                                        // for문 두번 돌면서 min인지 max인지 측정 . 

                                        if (max < Convert.ToInt32(anoterRpoertDetail["new_i_week"]))
                                        {
                                            max = Convert.ToInt32(anoterRpoertDetail["new_i_week"]);
                                        }

                                        if (min < Convert.ToInt32(anoterRpoertDetail["new_i_week"]))
                                        {
                                            min = Convert.ToInt32(anoterRpoertDetail["new_i_week"]);
                                        }
                                    }
                                    if (my == max)
                                    {
                                        //task update with d

                                    }
                                    else if (my == max)
                                    {
                                        //tash update with s

                                    }
                                    else
                                    {
                                        //task update only int
                                    }


                                }
                            }

                            //자신과 같은 작업을 가진, 다른 상세들 가져오기, (Entity)로 -> * Function 화 필요 * (F1)

                            //해당 Enttiy의 부모들을 가져오기

                            //개수가 1개이면 그냥 업데이트


                            //개수가 2개 이상이면 아래 로직 -> 이것도 Function화 필요 

                            //자기 자신이 가장 늦은주 ( 전주가 없다 ) -> S
                            //자기 자신이 가장 늦은주 X(전주가 있다) 
                            //자기 자신이 가장 빠른주 O (후주가 없다) -> D
                            //자기 자신이 가장 빠른주 X ( 중간이다 ) -> 기간만 반환


                            // TODO: Implement your custom Plug-in business logic.
                        }


                    }


                }


            }
            catch (Exception ex)
            {
                throw new InvalidPluginExecutionException(ex.Message);
            }
        }
    }
}
